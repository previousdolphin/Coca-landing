<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CoCA // ARCHIVE_LOCKED</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #ff0033; /* Neon Red */
            font-family: 'Courier New', Courier, monospace;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        #canvas-container { 
            position: absolute;
            inset: 0;
            z-index: 0;
            touch-action: none; 
        }

        /* Improved Modal Scrollbar */
        #content-modal { touch-action: pan-y; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0a0000; } 
        ::-webkit-scrollbar-thumb { background: #ff0033; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #ff3355; }

        .glitch-text { position: relative; animation: glitch 4s infinite; }
        @keyframes glitch {
            0% { text-shadow: 2px 2px 0px #330000; }
            94% { text-shadow: 2px 2px 0px #330000; transform: translate(0); }
            95% { text-shadow: -2px 2px 0px #330000; transform: translate(1px, 1px); }
            96% { text-shadow: 2px -2px 0px #330000; transform: translate(-1px, -1px); }
            97% { text-shadow: -2px -2px 0px #330000; transform: translate(0); }
            100% { text-shadow: 2px 2px 0px #330000; }
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
        }
        
        /* Utility for Modal content wrapper */
        .modal-wrapper {
            box-shadow: 0 0 100px rgba(255, 0, 51, 0.1);
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <!-- Reduced opacity for cleaner look -->
    <div class="absolute inset-0 z-50 pointer-events-none scanlines mix-blend-overlay opacity-20"></div>
    <div class="absolute inset-0 z-50 pointer-events-none" style="background: radial-gradient(circle, transparent 30%, black 150%);"></div>

    <!-- HUD -->
    <div id="ui-layer" class="absolute inset-0 z-10 pointer-events-none p-4 md:p-8 flex flex-col justify-between">
        <div class="flex justify-between items-start">
            <div class="border border-[#ff0033] bg-black/80 px-4 py-2 backdrop-blur-sm shadow-[0_0_15px_rgba(255,0,51,0.15)] rounded-sm">
                <div class="flex items-center gap-3">
                    <i data-lucide="lock" class="w-4 h-4 animate-pulse"></i>
                    <span class="text-xs md:text-sm font-bold tracking-[0.2em]">CoCA_ARCHIVE_V2</span>
                </div>
            </div>
            <!-- Cleaner Zoom Indicator -->
            <div class="flex flex-col items-end gap-1">
                 <div class="text-[10px] tracking-widest opacity-70">OPTICAL_ZOOM</div>
                 <div class="text-xl font-bold font-mono text-[#ff0033]"><span id="hud-zoom">70</span>mm</div>
            </div>
        </div>

        <div id="center-prompt" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center transition-all duration-700 w-full px-4">
            <div class="text-5xl mb-6 opacity-40 animate-bounce duration-1000"><i data-lucide="fingerprint" class="mx-auto w-16 h-16 stroke-1"></i></div>
            <div class="text-xs md:text-sm tracking-[0.3em] bg-black/90 px-6 py-3 inline-block border border-[#ff0033]/50 shadow-[0_0_20px_rgba(255,0,51,0.2)] hover:bg-[#ff0033] hover:text-black transition-all cursor-pointer pointer-events-auto rounded-sm">
                INITIALIZE_HANDSHAKE
            </div>
        </div>

        <div class="flex justify-between items-end text-[10px] md:text-xs opacity-50 tracking-wider">
            <div>
                SYS: <span id="hud-pulse" class="text-[#ff0033]">ONLINE</span><br>
                LAT: <span id="debug-lat">00.00</span>
            </div>
            <div class="text-right">
                SECURE_CONNECTION<br>
                ENCRYPTED_SHA256
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div id="content-modal" class="absolute inset-0 z-40 hidden flex items-center justify-center bg-black/90 backdrop-blur-sm transition-all duration-500 opacity-0 px-4 cursor-pointer">
        <!-- Close Button -->
        <button id="close-btn" class="absolute top-6 right-6 z-50 pointer-events-auto p-2 border border-[#ff0033] bg-black/50 text-[#ff0033] hover:bg-[#ff0033] hover:text-black transition-all duration-300 shadow-[0_0_20px_rgba(255,0,51,0.2)] rounded-sm">
            <i data-lucide="x" class="w-6 h-6"></i>
        </button>

        <div id="modal-wrapper" class="relative w-full max-w-5xl h-[80vh] md:h-[75vh] flex flex-col md:flex-row border border-[#ff0033] bg-black shadow-[0_0_100px_rgba(255,0,51,0.1)] pointer-events-auto overflow-hidden rounded-sm cursor-auto">
            <!-- Decorative Sidebar -->
            <div class="h-14 md:h-auto md:w-16 border-b md:border-b-0 md:border-r border-[#ff0033]/30 flex flex-row md:flex-col items-center justify-between md:justify-center md:py-8 px-6 md:px-0 gap-8 bg-[#0a0000] shrink-0">
                <i data-lucide="database" class="w-5 h-5 opacity-60"></i>
                <div class="w-full h-px md:w-px md:h-24 bg-gradient-to-r md:bg-gradient-to-b from-transparent via-[#ff0033]/50 to-transparent"></div>
                <div class="text-[10px] md:-rotate-90 tracking-[0.2em] opacity-60 font-bold whitespace-nowrap">RESTRICTED AREA</div>
            </div>

            <!-- Content Area -->
            <div id="modal-content-area" class="flex-1 p-8 md:p-12 overflow-y-auto relative overscroll-contain custom-scrollbar">
                <!-- Background Decoration -->
                <div class="absolute top-0 right-0 p-8 opacity-5 pointer-events-none select-none">
                    <i data-lucide="shield-alert" class="w-64 h-64"></i>
                </div>

                <div class="border-b border-[#ff0033]/50 pb-6 mb-8 relative">
                    <div class="absolute -left-2 top-0 bottom-0 w-1 bg-[#ff0033]"></div>
                    <h2 id="modal-title" class="text-3xl md:text-5xl font-black tracking-tighter glitch-text mb-3 text-white pl-4">REPO_000</h2>
                    <div class="flex flex-wrap gap-3 pl-4">
                         <span class="bg-[#ff0033] text-black text-[10px] font-bold px-2 py-1 rounded-sm flex items-center gap-2">
                            <i data-lucide="lock" class="w-3 h-3"></i> ENCRYPTED
                        </span>
                        <span class="border border-[#ff0033]/50 text-[#ff0033] text-[10px] font-bold px-3 py-1 rounded-sm tracking-widest">
                            NODE_ID: <span id="modal-id">000</span>
                        </span>
                    </div>
                </div>

                <div class="prose prose-invert max-w-none text-[#ffcccc] text-sm md:text-base leading-relaxed font-mono">
                    <p class="text-xl mb-8 font-light text-white/90">
                        <span class="text-[#ff0033] font-bold">>>> ACCESS GRANTED.</span><br>
                        Welcome to the Church of Conceptual Art (CoCA) Intellectual Property Vault.
                    </p>
                    
                    <p class="mb-6 opacity-80">
                        You have successfully established a secure neural link to Archive Node <span id="modal-id-inline" class="text-white">000</span>. This artifact represents a crystallized moment of conceptual ideation, preserved against the entropy of the digital void.
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-10">
                        <div class="border border-[#ff0033]/30 p-5 bg-gradient-to-br from-[#ff0033]/10 to-transparent rounded-sm hover:border-[#ff0033] transition-colors duration-300">
                            <h3 class="font-bold text-[#ff0033] mb-3 text-xs flex items-center gap-2 tracking-widest">
                                <i data-lucide="hash" class="w-4 h-4"></i> HASH_VERIFICATION
                            </h3>
                            <p class="text-xs opacity-70 font-mono">0x7F...3A2B [MATCH]</p>
                            <p class="text-xs opacity-60 mt-2">Integrity verified across the distributed ledger.</p>
                        </div>
                        <div class="border border-[#ff0033]/30 p-5 bg-gradient-to-br from-[#ff0033]/10 to-transparent rounded-sm hover:border-[#ff0033] transition-colors duration-300">
                            <h3 class="font-bold text-[#ff0033] mb-3 text-xs flex items-center gap-2 tracking-widest">
                                <i data-lucide="archive" class="w-4 h-4"></i> STORAGE_PROTOCOL
                            </h3>
                            <p class="text-xs opacity-70 font-mono">COLD_STORAGE // TIER_1</p>
                            <p class="text-xs opacity-60 mt-2">Redundant copies exist in Sector 7 and 9.</p>
                        </div>
                    </div>
                    
                    <div class="border-t border-[#ff0033]/20 pt-8 mt-12 flex items-center justify-between opacity-50 text-xs">
                        <span>SESSION_ID: <span class="text-[#ff0033]">#AF9920</span></span>
                        <span>TERMINAL_V2.4</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Shaders (Optimized) ---
        
        const vertexShader = `
            varying vec2 vUv;
            
            uniform float uFlatten; 
            uniform float uWidth;
            uniform float uHeight;

            void main() {
                vUv = uv;
                vec3 spherePos = position;
                vec3 flatPos = vec3((vUv.x - 0.5) * uWidth, (vUv.y - 0.5) * uHeight, 0.0);
                vec3 finalPos = mix(spherePos, flatPos, uFlatten);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            uniform vec3 uColor;
            uniform float uOpacity;
            uniform float uHover;
            uniform float uActive;
            uniform float uPulse; 
            uniform sampler2D uLabel;
            uniform sampler2D uLogo; 
            
            varying vec2 vUv;

            void main() {
                // 1. INPUTS
                vec4 labelColor = texture2D(uLabel, vUv);
                float textAlpha = labelColor.a; 
                
                vec2 centeredUV = (vUv - 0.5) * 0.9 + 0.5; 
                vec4 logoTex = texture2D(uLogo, centeredUV);
                float logoShape = logoTex.a; 
                logoShape = smoothstep(0.05, 0.2, logoShape);

                // 2. MASKING
                float textMask = smoothstep(0.0, 0.5, textAlpha);
                float logoVisibility = 1.0 - (textMask * 0.98); // Increased masking

                // 3. COLOR LAYERS
                vec3 neonRed = uColor;
                vec3 pureWhite = vec3(1.0, 1.0, 1.0);

                // LAYER A: Background Effects
                float border = 0.0;
                float bw = 0.02; // Slightly thicker border for "tight" look
                if (vUv.x < bw || vUv.x > 1.0 - bw || vUv.y < bw || vUv.y > 1.0 - bw) border = 1.0;
                
                float grid = 0.0;
                if (mod(vUv.x * 10.0, 1.0) < 0.05 || mod(vUv.y * 10.0, 1.0) < 0.05) grid = 0.15; 
                
                // Slowed down scanline in shader too
                float scanline = sin(vUv.y * 150.0 + uTime * 0.5) * 0.05; 
                
                float bgBrightness = (grid * 0.3) + scanline;
                bgBrightness *= (1.0 - logoShape) * (1.0 - textMask);

                // LAYER B: Logo
                float logoBrightness = logoShape * 1.6 * logoVisibility;

                // LAYER C: Text
                float textBrightness = textAlpha * 1.3;

                // 4. STATES
                float pulseGlow = uPulse * 0.6; 
                float highlight = uHover + uActive;
                float globalGain = 1.0 + pulseGlow + highlight;

                // 5. COMPOSITION
                vec3 finalColor = vec3(0.0);
                
                // Red Channel
                finalColor += neonRed * (bgBrightness + logoBrightness + border * 0.5) * globalGain;
                
                // White Channel (Text + Border Highlight)
                finalColor += pureWhite * (textBrightness + (border * 0.5 * highlight)) * globalGain;

                // 6. OPACITY
                float fill = 0.02 + (uHover * 0.05) + (uActive * 0.95) + (uPulse * 0.2);
                float shapeAlpha = max(border, max(logoShape, textAlpha));
                float totalAlpha = (shapeAlpha + fill) * uOpacity;
                totalAlpha = min(totalAlpha, 1.0);

                // Flash white
                if (uPulse > 0.8 && uActive < 0.1) {
                    finalColor = mix(finalColor, vec3(1.0), (uPulse - 0.8) * 3.0);
                }

                gl_FragColor = vec4(finalColor, totalAlpha);
            }
        `;

        // --- Config ---
        const SPHERE_RADIUS = 16; // Increased radius for fuller screen feel
        const NEON_RED = new THREE.Color('#ff0033'); 
        
        // Increased Density for "Rounder" feel
        const DATA_ROWS = 14; 
        const DATA_COLS = 20; 
        
        let scene, camera, renderer, raycaster, mouse;
        let meshes = []; 
        let meshFlatList = []; 
        let simGrid = []; 
        let globalLogoTexture; 

        const state = {
            activeId: null,
            startTime: Date.now(),
            cameraLat: 0,
            cameraLon: 90,
            zoomFOV: 65, // Tighter FOV for less distortion (telephoto feel)
            isDragging: false,
            touchStartX: 0,
            touchStartY: 0,
            lastTouchX: 0,
            lastTouchY: 0,
            hasInteracted: false,
            pinchStartDist: 0,
            pinchStartFOV: 65,
            lastSimTime: 0 // For slowing down simulation
        };

        // DOM Elements
        const uiZoom = document.getElementById('hud-zoom');
        const debugLat = document.getElementById('debug-lat');
        const contentModal = document.getElementById('content-modal');
        const centerPrompt = document.getElementById('center-prompt');
        const modalTitle = document.getElementById('modal-title');
        const modalId = document.getElementById('modal-id');
        const modalIdInline = document.getElementById('modal-id-inline');

        lucide.createIcons();

        function createLabelTexture(number) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Background is transparent
            ctx.clearRect(0,0,size,size);
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Tighter Font
            ctx.font = 'bold 120px "Courier New", monospace';
            ctx.fillStyle = '#ffffff';
            
            const text = number.toString().padStart(3, '0');
            ctx.fillText(text, size/2, size/2);
            
            // Cleaner Box
            ctx.lineWidth = 12; 
            ctx.strokeStyle = '#ffffff';
            // Slightly smaller box relative to text for tightness
            ctx.strokeRect(size * 0.2, size * 0.35, size * 0.6, size * 0.3);
            
            return new THREE.CanvasTexture(canvas);
        }

        function createPlaceholderLogo() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            
            ctx.fillStyle = '#000000'; 
            ctx.beginPath();
            ctx.arc(size/2, size/2, size*0.48, 0, Math.PI * 2); // Bigger fill
            ctx.fill(); 

            ctx.globalCompositeOperation = 'destination-out';
            ctx.font = '900 350px sans-serif'; // Bolder
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("C", size/2, size/2);
            ctx.globalCompositeOperation = 'source-over';

            return new THREE.CanvasTexture(canvas);
        }

        function normalizeUVs(geometry) {
            const uvAttribute = geometry.attributes.uv;
            let minU = Infinity, maxU = -Infinity;
            let minV = Infinity, maxV = -Infinity;
            for (let i = 0; i < uvAttribute.count; i++) {
                const u = uvAttribute.getX(i);
                const v = uvAttribute.getY(i);
                if (u < minU) minU = u;
                if (u > maxU) maxU = u;
                if (v < minV) minV = v;
                if (v > maxV) maxV = v;
            }
            const rangeU = maxU - minU;
            const rangeV = maxV - minV;
            if (rangeU < 0.0001 || rangeV < 0.0001) return; 
            for (let i = 0; i < uvAttribute.count; i++) {
                const u = uvAttribute.getX(i);
                const v = uvAttribute.getY(i);
                uvAttribute.setXY(i, (u - minU) / rangeU, (v - minV) / rangeV);
            }
            uvAttribute.needsUpdate = true;
        }

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050000); 
            scene.fog = new THREE.FogExp2(0x050000, 0.012); // Slightly less fog

            camera = new THREE.PerspectiveCamera(state.zoomFOV, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(-100, -100);

            const textureLoader = new THREE.TextureLoader();
            globalLogoTexture = createPlaceholderLogo(); 

            textureLoader.load(
                'CoCA-Vector-redrawn-photoshop.svg', 
                (tex) => {
                    console.log("SVG Loaded.");
                    tex.minFilter = THREE.LinearFilter; 
                    tex.magFilter = THREE.LinearFilter;
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Crisper textures at angles
                    meshFlatList.forEach(mesh => {
                        mesh.material.uniforms.uLogo.value = tex;
                    });
                },
                undefined,
                (err) => { console.warn("Using placeholder logo."); }
            );

            // Tighter packing
            const phiStep = Math.PI / DATA_ROWS;
            const thetaStep = (Math.PI * 2) / DATA_COLS;
            let idCounter = 1;

            meshes = new Array(DATA_ROWS).fill(0).map(() => new Array(DATA_COLS));
            simGrid = new Array(DATA_ROWS).fill(0).map(() => new Array(DATA_COLS).fill(0));

            for(let r=0; r<DATA_ROWS; r++) {
                for(let c=0; c<DATA_COLS; c++) {
                    // Adjusted content band to match new resolution
                    const isContent = (r >= 4 && r <= 10); 
                    
                    const phiStart = c * thetaStep; 
                    const phiLen = thetaStep * 0.98; // Slight gap for individual card feel
                    const thetaStart = r * phiStep;
                    const thetaLen = phiStep * 0.98;

                    const geo = new THREE.SphereGeometry(
                        SPHERE_RADIUS, 
                        16, 16, 
                        phiStart, phiLen, 
                        thetaStart, thetaLen
                    );
                    normalizeUVs(geo); 

                    const labelTex = createLabelTexture(idCounter);

                    const avgTheta = thetaStart + thetaLen/2; 
                    const radiusAtLat = SPHERE_RADIUS * Math.sin(avgTheta);
                    const flatWidth = radiusAtLat * phiLen;
                    const flatHeight = SPHERE_RADIUS * thetaLen;

                    const material = new THREE.ShaderMaterial({
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        uniforms: {
                            uTime: { value: 0 },
                            uColor: { value: NEON_RED },
                            uOpacity: { value: isContent ? 0.9 : 0.3 },
                            uHover: { value: 0 },
                            uActive: { value: 0 },
                            uPulse: { value: 0 }, 
                            uFlatten: { value: 0 },
                            uWidth: { value: Math.max(flatWidth, 1.0) },
                            uHeight: { value: flatHeight },
                            uLabel: { value: labelTex },
                            uLogo: { value: globalLogoTexture }
                        },
                        side: THREE.DoubleSide, 
                        transparent: true,
                        depthWrite: false, 
                        blending: THREE.AdditiveBlending
                    });

                    const mesh = new THREE.Mesh(geo, material);
                    
                    const centerPhi = phiStart + phiLen/2; 
                    const centerTheta = thetaStart + thetaLen/2;
                    const x = -SPHERE_RADIUS * Math.sin(centerTheta) * Math.cos(centerPhi);
                    const y = SPHERE_RADIUS * Math.cos(centerTheta);
                    const z = SPHERE_RADIUS * Math.sin(centerTheta) * Math.sin(centerPhi);
                    const centerPos = new THREE.Vector3(x, y, z);
                    
                    const nodeTitle = `REPO_${idCounter.toString().padStart(3,'0')}`;

                    mesh.userData = { 
                        id: idCounter, 
                        row: r,
                        col: c,
                        isContent: isContent,
                        title: nodeTitle,
                        centerPos: centerPos
                    };

                    scene.add(mesh);
                    meshes[r][c] = mesh;
                    meshFlatList.push(mesh);
                    // Initialize grid with reduced random noise
                    simGrid[r][c] = Math.random() > 0.95 ? 1.0 : 0.0;
                    idCounter++;
                }
            }

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('click', onClick, false);
            window.addEventListener('wheel', onWheel, { passive: false });
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd, { passive: false });
            
            animate();
        }

        // --- CLOSING LOGIC (Minimizing Details) ---
        function closeModal() {
            contentModal.classList.add('opacity-0');
            setTimeout(() => { 
                contentModal.classList.add('hidden'); 
                state.activeId = null; 
                // Reset mouse to prevent immediate re-hover trigger
                mouse.x = -100; 
                mouse.y = -100; 
            }, 300);
        }

        document.getElementById('close-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            closeModal();
        });

        // Click Outside to Minimize
        contentModal.addEventListener('click', (e) => {
            if(e.target === contentModal) {
                closeModal();
            }
        });

        // --- SIMULATION ---
        function updateSimulation() {
            const nextGrid = new Array(DATA_ROWS).fill(0).map(() => new Array(DATA_COLS).fill(0));
            
            // Randomly seed, but much less often
            if (Math.random() < 0.01) {
                const rr = Math.floor(Math.random() * DATA_ROWS);
                const cc = Math.floor(Math.random() * DATA_COLS);
                simGrid[rr][cc] = 1.0;
            }

            for(let r=0; r<DATA_ROWS; r++) {
                for(let c=0; c<DATA_COLS; c++) {
                    let val = simGrid[r][c];
                    
                    // Slower decay for smoother trails
                    val *= 0.95; 
                    
                    const cLeft = (c - 1 + DATA_COLS) % DATA_COLS;
                    const cRight = (c + 1) % DATA_COLS;
                    const rUp = Math.max(0, r - 1);
                    const rDown = Math.min(DATA_ROWS - 1, r + 1);
                    
                    const neighbors = [ simGrid[r][cLeft], simGrid[r][cRight], simGrid[rUp][c], simGrid[rDown][c], simGrid[rUp][cLeft], simGrid[rDown][cRight] ];
                    let activeNeighbors = 0;
                    neighbors.forEach(n => { if(n > 0.5) activeNeighbors++; });

                    if (val < 0.2 && activeNeighbors >= 2 && activeNeighbors <= 4 && Math.random() < 0.4) val = 1.0; 
                    if (Math.random() < 0.0005) val = 1.0;
                    
                    nextGrid[r][c] = Math.max(0.0, Math.min(val, 1.0));
                }
            }
            simGrid = nextGrid;
        }

        // --- Interaction ---
        function handleFirstInteraction() {
            if (!state.hasInteracted) {
                state.hasInteracted = true;
                if(centerPrompt) {
                    centerPrompt.style.opacity = '0';
                    setTimeout(() => centerPrompt.style.display = 'none', 700);
                }
            }
        }
        function onWheel(e) { e.preventDefault(); if(state.activeId !== null) return; state.zoomFOV = Math.max(20, Math.min(100, state.zoomFOV + e.deltaY * 0.05)); camera.fov = state.zoomFOV; camera.updateProjectionMatrix(); uiZoom.innerText = Math.round(state.zoomFOV); }
        function onTouchStart(e) { handleFirstInteraction(); if (state.activeId !== null) return; if (e.touches.length === 1) { state.isDragging = true; state.touchStartX = state.lastTouchX = e.touches[0].clientX; state.touchStartY = state.lastTouchY = e.touches[0].clientY; } else if (e.touches.length === 2) { state.pinchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); state.pinchStartFOV = state.zoomFOV; state.isDragging = false; } }
        function onTouchMove(e) { if (state.activeId !== null) return; if (e.touches.length === 1 && state.isDragging) { const x = e.touches[0].clientX; const y = e.touches[0].clientY; state.cameraLon -= (x - state.lastTouchX) * 0.5; state.cameraLat += (y - state.lastTouchY) * 0.5; state.lastTouchX = x; state.lastTouchY = y; } else if (e.touches.length === 2) { const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); state.zoomFOV = Math.max(20, Math.min(100, state.pinchStartFOV * (state.pinchStartDist / dist))); camera.fov = state.zoomFOV; camera.updateProjectionMatrix(); uiZoom.innerText = Math.round(state.zoomFOV); } }
        function onTouchEnd(e) { if (state.activeId !== null) return; state.isDragging = false; if(e.changedTouches.length === 1 && e.touches.length === 0 && Math.hypot(e.changedTouches[0].clientX - state.touchStartX, e.changedTouches[0].clientY - state.touchStartY) < 10) { mouse.x = (e.changedTouches[0].clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.changedTouches[0].clientY / window.innerHeight) * 2 + 1; checkIntersection(); } }
        function onMouseDown(e) { handleFirstInteraction(); if(state.activeId !== null) return; state.isDragging = true; state.lastTouchX = e.clientX; state.lastTouchY = e.clientY; }
        function onMouseMove(e) { mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; if(state.isDragging && state.activeId === null) { state.cameraLon -= (e.clientX - state.lastTouchX) * 0.1; state.cameraLat += (e.clientY - state.lastTouchY) * 0.1; state.lastTouchX = e.clientX; state.lastTouchY = e.clientY; } }
        function onMouseUp() { state.isDragging = false; }
        function onClick() { if(state.activeId === null) checkIntersection(); }
        
        // --- OPTIMIZED RAYCASTING ---
        function checkIntersection() { 
            raycaster.setFromCamera(mouse, camera); 
            // Only check intersection on Click event
            const intersects = raycaster.intersectObjects(meshFlatList); 
            if(intersects.length > 0) activateNode(intersects[0].object.userData); 
        }

        function activateNode(data) { 
            state.activeId = data.id; 
            modalTitle.innerText = data.title; 
            modalId.innerText = data.id.toString().padStart(3, '0'); 
            modalIdInline.innerText = data.id.toString().padStart(3, '0');
            contentModal.classList.remove('hidden'); 
            setTimeout(() => contentModal.classList.remove('opacity-0'), 50); 
        }
        
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const time = (now - state.startTime) * 0.001;

            // --- SIMULATION TIMING (200% Slower) ---
            // Run sim every 150ms instead of 16ms
            if (now - state.lastSimTime > 150) {
                updateSimulation();
                state.lastSimTime = now;
            }

            // --- OPTIMIZED HOVER LOGIC ---
            // Don't raycast inside the loop. Do it once.
            let hoveredObject = null;
            if (!state.isDragging && state.activeId === null) {
                // Check if mouse is on screen
                if (mouse.x > -1 && mouse.x < 1 && mouse.y > -1 && mouse.y < 1) {
                    raycaster.setFromCamera(mouse, camera);
                    // This is the heavy operation, done only once per frame now
                    const intersects = raycaster.intersectObjects(meshFlatList);
                    if (intersects.length > 0) {
                        hoveredObject = intersects[0].object;
                    }
                }
            }

            // Camera Movement
            if(state.activeId === null) {
                state.cameraLat = Math.max(-85, Math.min(85, state.cameraLat));
                if(!state.isDragging && state.hasInteracted) state.cameraLon += 0.03; // Smooth rotation
                
                // Debug UI
                if(debugLat) debugLat.innerText = state.cameraLat.toFixed(2);

                const phi = THREE.MathUtils.degToRad(90 - state.cameraLat);
                const theta = THREE.MathUtils.degToRad(state.cameraLon);
                const targetX = Math.sin(phi) * Math.cos(theta);
                const targetY = Math.cos(phi);
                const targetZ = Math.sin(phi) * Math.sin(theta);
                camera.position.set(0,0,0);
                camera.lookAt(targetX, targetY, targetZ);
            }

            // Mesh Updates
            meshFlatList.forEach((mesh) => {
                const mat = mesh.material;
                const data = mesh.userData;
                
                mat.uniforms.uTime.value = time;
                mat.uniforms.uPulse.value = simGrid[data.row][data.col];

                // Hover check is now O(1) inside loop
                let isHovered = (mesh === hoveredObject);
                
                // Camera Center Check (Falloff hover)
                if(!state.isDragging && state.activeId === null && !isHovered) {
                    const c = new THREE.Vector3(); 
                    camera.getWorldDirection(c); 
                    const dir = data.centerPos.clone().normalize();
                    // Increased strictness for cleaner center-only highlight
                    if(dir.dot(c) > 0.985) isHovered = true;
                }
                
                // Smoothly interpolate hover state
                mat.uniforms.uHover.value += ((isHovered ? 1.0 : 0.0) - mat.uniforms.uHover.value) * 0.1;

                if(state.activeId !== null) {
                    if(data.id === state.activeId) {
                        const dist = 3.5; // Closer zoom
                        const dir = new THREE.Vector3(); 
                        camera.getWorldDirection(dir);
                        const targetPos = camera.position.clone().add(dir.multiplyScalar(dist));
                        mesh.position.lerp(targetPos, 0.08);
                        mesh.lookAt(camera.position); 
                        mat.uniforms.uFlatten.value += (1.0 - mat.uniforms.uFlatten.value) * 0.05;
                        mat.uniforms.uActive.value = 1.0;
                        mat.uniforms.uOpacity.value = 1.0;
                    } else {
                        // Return to sphere
                        mesh.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                        mesh.lookAt(new THREE.Vector3(0,0,0)); 
                        mesh.quaternion.slerp(new THREE.Quaternion(), 0.1);
                        mat.uniforms.uFlatten.value += (0.0 - mat.uniforms.uFlatten.value) * 0.1;
                        mat.uniforms.uActive.value = 0.0;
                        mat.uniforms.uOpacity.value += (0.05 - mat.uniforms.uOpacity.value) * 0.1;
                    }
                } else {
                    mesh.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                    mesh.quaternion.slerp(new THREE.Quaternion(), 0.1);
                    mat.uniforms.uFlatten.value += (0.0 - mat.uniforms.uFlatten.value) * 0.1;
                    mat.uniforms.uActive.value = 0.0;
                    const baseOp = data.isContent ? 0.9 : 0.25;
                    mat.uniforms.uOpacity.value += (baseOp - mat.uniforms.uOpacity.value) * 0.05;
                }
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
