<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CoCA // ARCHIVE_MIRROR_SITE</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #ff0033; /* Neon Red */
            font-family: 'Courier New', Courier, monospace;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            cursor: crosshair; 
        }
        
        #canvas-container { 
            position: absolute;
            inset: 0;
            z-index: 0;
            touch-action: none; 
        }

        #waveform-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            z-index: 5;
            pointer-events: none;
            mix-blend-mode: lighten;
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <canvas id="waveform-layer"></canvas>

    <!-- Reduced opacity for cleaner look -->
    <div class="absolute inset-0 z-50 pointer-events-none scanlines mix-blend-overlay opacity-20"></div>
    <div class="absolute inset-0 z-50 pointer-events-none" style="background: radial-gradient(circle, transparent 30%, black 150%);"></div>

    <!-- HUD -->
    <div id="ui-layer" class="absolute inset-0 z-10 pointer-events-none p-4 md:p-8 flex flex-col justify-between">
        <div class="flex justify-between items-start">
            <div class="border border-[#ff0033] bg-black/80 px-4 py-2 backdrop-blur-sm shadow-[0_0_15px_rgba(255,0,51,0.15)] rounded-sm">
                <div class="flex items-center gap-3">
                    <i data-lucide="globe" class="w-4 h-4 animate-pulse"></i>
                    <span class="text-xs md:text-sm font-bold tracking-[0.2em]">CoCA_MIRROR_SITE</span>
                </div>
            </div>
            <div class="flex flex-col items-end gap-1">
                 <div class="text-[10px] tracking-widest opacity-70">ORBITAL_VIEW</div>
                 <div class="text-xl font-bold font-mono text-[#ff0033]"><span id="hud-zoom">190</span>%</div>
            </div>
        </div>

        <div class="flex justify-between items-end text-[10px] md:text-xs opacity-50 tracking-wider">
            <div>
                SYS: <span class="text-[#ff0033]">SLEEP_MODE</span><br>
                MOMENTUM: <span id="debug-mom">0.00</span>
            </div>
            <div class="text-right">
                EXTERNAL_ACCESS_ONLY<br>
                SECURE_CONNECTION
            </div>
        </div>
    </div>

    <script>
        // --- Node Shaders (Transparent) ---
        const nodeVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const nodeFragmentShader = `
            uniform vec3 uColor;
            uniform float uOpacity;
            uniform float uHover;
            uniform sampler2D uLabel;
            
            varying vec2 vUv;

            void main() {
                vec4 labelColor = texture2D(uLabel, vUv);
                float textAlpha = labelColor.a; 
                
                vec3 pureWhite = vec3(1.0, 1.0, 1.0);
                
                float border = 0.0;
                float bw = 0.02; 
                if (vUv.x < bw || vUv.x > 1.0 - bw || vUv.y < bw || vUv.y > 1.0 - bw) border = 1.0;

                vec3 finalColor = vec3(0.0);
                finalColor += pureWhite * textAlpha * 1.5;
                
                float borderStrength = border * (0.3 + uHover * 0.7);
                finalColor += uColor * borderStrength;

                float baseAlpha = 0.05 + (uHover * 0.1);
                float totalAlpha = max(textAlpha, max(border * 0.5, baseAlpha)) * uOpacity;

                gl_FragColor = vec4(finalColor, totalAlpha);
            }
        `;

        // --- Coin Shader (Volumetric Stack - Fixed) ---
        const coinVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const coinFragmentShader = `
            uniform sampler2D uTexture;
            uniform vec3 uColor;
            uniform float uTime;
            varying vec2 vUv;

            void main() {
                // 1. FORCE CIRCULAR CROP
                // This eliminates the "square" plane corners completely
                float dist = distance(vUv, vec2(0.5));
                if (dist > 0.49) discard; // Cut off anything outside circle

                // 2. TEXTURE SAMPLING
                vec4 tex = texture2D(uTexture, vUv);
                float shape = tex.a; 
                
                // 3. HARD CUTOUT (Alpha Test)
                // If the texture itself is transparent (the logo cutout), discard.
                if (shape < 0.4) discard; 

                // 4. EDGE HIGHLIGHT
                // Mix shape alpha edge AND geometric circle edge
                float geoEdge = smoothstep(0.45, 0.48, dist); // White ring at outer rim
                float texEdge = smoothstep(0.4, 0.5, shape) * (1.0 - smoothstep(0.6, 0.7, shape)); // White ring at texture edge
                
                float totalEdge = max(geoEdge, texEdge);

                // 5. COLOR
                // Sleeping Pulse
                float pulse = 0.6 + 0.4 * (0.5 + 0.5 * sin(uTime * 1.5));
                vec3 baseColor = uColor * pulse * 2.0; 
                
                // Mix White Edge + Red Core
                vec3 finalColor = mix(baseColor, vec3(1.0, 1.0, 1.0), totalEdge); 
                
                // Output opaque alpha for depth writing
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;


        // --- Config ---
        const SPHERE_RADIUS = 16; 
        const NEON_RED = new THREE.Color('#ff0033'); 
        const DATA_ROWS = 14; 
        const DATA_COLS = 20; 
        
        const REFERENCE_ZOOM_Z = 75; 
        const DEFAULT_ZOOM_Z = 40; 
        const IDLE_TIMEOUT = 3000; 
        
        let scene, camera, renderer, raycaster, mouse;
        let sphereGroup, coinGroup; 
        let meshes = []; 
        let meshFlatList = []; 
        let coinLayers = [];
        
        const waveCanvas = document.getElementById('waveform-layer');
        const waveCtx = waveCanvas.getContext('2d');

        const state = {
            startTime: Date.now(),
            rotLon: 0,
            rotLat: 0,
            velocityLon: 0.1, 
            velocityLat: 0,
            cameraZ: DEFAULT_ZOOM_Z, 
            isDragging: false,
            lastTouchX: 0,
            lastTouchY: 0,
            lastInteractionTime: Date.now(),
            pinchStartDist: 0,
            pinchStartZ: DEFAULT_ZOOM_Z
        };

        const debugMom = document.getElementById('debug-mom');
        const uiZoom = document.getElementById('hud-zoom');
        lucide.createIcons();

        function createLabelTexture(number) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 120px "Courier New", monospace';
            ctx.fillStyle = '#ffffff';
            const text = number.toString().padStart(3, '0');
            ctx.fillText(text, size/2, size/2);
            ctx.lineWidth = 12; 
            ctx.strokeStyle = '#ffffff';
            ctx.strokeRect(size * 0.2, size * 0.35, size * 0.6, size * 0.3);
            return new THREE.CanvasTexture(canvas);
        }

        function createPlaceholderLogo() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.fillStyle = '#000000'; 
            ctx.beginPath();
            ctx.arc(size/2, size/2, size*0.48, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.globalCompositeOperation = 'destination-out';
            ctx.font = '900 350px sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("C", size/2, size/2);
            ctx.globalCompositeOperation = 'source-over';
            return new THREE.CanvasTexture(canvas);
        }

        function normalizeUVs(geometry) {
            const uvAttribute = geometry.attributes.uv;
            let minU = Infinity, maxU = -Infinity;
            let minV = Infinity, maxV = -Infinity;
            for (let i = 0; i < uvAttribute.count; i++) {
                const u = uvAttribute.getX(i);
                const v = uvAttribute.getY(i);
                if (u < minU) minU = u;
                if (u > maxU) maxU = u;
                if (v < minV) minV = v;
                if (v > maxV) maxV = v;
            }
            const rangeU = maxU - minU;
            const rangeV = maxV - minV;
            if (rangeU < 0.0001 || rangeV < 0.0001) return; 
            for (let i = 0; i < uvAttribute.count; i++) {
                const u = uvAttribute.getX(i);
                const v = uvAttribute.getY(i);
                uvAttribute.setXY(i, (u - minU) / rangeU, (v - minV) / rangeV);
            }
            uvAttribute.needsUpdate = true;
        }

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050000); 
            scene.fog = new THREE.FogExp2(0x050000, 0.015);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 0, state.cameraZ);
            camera.lookAt(0, 0, 0);

            // Robust Renderer for Mobile
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true, 
                powerPreference: "high-performance",
                precision: "mediump" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(-100, -100);

            sphereGroup = new THREE.Group();
            scene.add(sphereGroup);

            coinGroup = new THREE.Group();
            scene.add(coinGroup);

            const textureLoader = new THREE.TextureLoader();
            const placeholderTex = createPlaceholderLogo();
            
            const coinUniforms = {
                uTexture: { value: placeholderTex },
                uColor: { value: NEON_RED },
                uTime: { value: 0 }
            };

            // COIN SETUP (Reduced count for mobile perf, maintained visual density)
            const layers = 25; 
            const thickness = 2.5; 
            const coinSize = 22; 

            for(let i=0; i<layers; i++) {
                const layerGeo = new THREE.PlaneGeometry(coinSize, coinSize);
                
                // CRITICAL: Transparent FALSE + AlphaTest ensures depth write works on iOS
                const layerMat = new THREE.ShaderMaterial({
                    vertexShader: coinVertexShader,
                    fragmentShader: coinFragmentShader,
                    uniforms: coinUniforms,
                    transparent: false, 
                    depthWrite: true,
                    alphaTest: 0.5, 
                    side: THREE.DoubleSide,
                });
                
                const layerMesh = new THREE.Mesh(layerGeo, layerMat);
                const zPos = ((i / (layers-1)) * thickness) - (thickness/2);
                layerMesh.position.z = zPos;
                coinGroup.add(layerMesh);
                coinLayers.push(layerMesh);
            }

            textureLoader.load(
                'CoCA-Vector-redrawn-photoshop.svg', 
                (tex) => {
                    console.log("SVG Loaded.");
                    // Disable mipmaps for cleaner edges on mobile
                    tex.minFilter = THREE.LinearFilter; 
                    tex.magFilter = THREE.LinearFilter;
                    tex.generateMipmaps = false; 
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    coinUniforms.uTexture.value = tex;
                },
                undefined,
                (err) => { console.warn("Using placeholder logo."); }
            );

            // --- SPHERE GENERATION ---
            const phiStep = Math.PI / DATA_ROWS;
            const thetaStep = (Math.PI * 2) / DATA_COLS;
            let idCounter = 1;

            meshes = new Array(DATA_ROWS).fill(0).map(() => new Array(DATA_COLS));

            for(let r=3; r<=10; r++) {
                for(let c=0; c<DATA_COLS; c++) {
                    const isContent = (r >= 4 && r <= 9); 
                    
                    const phiStart = c * thetaStep; 
                    const phiLen = thetaStep * 0.98; 
                    const thetaStart = r * phiStep;
                    const thetaLen = phiStep * 0.98; 

                    const geo = new THREE.SphereGeometry(
                        SPHERE_RADIUS, 
                        16, 16, 
                        phiStart, phiLen, 
                        thetaStart, thetaLen
                    );
                    normalizeUVs(geo); 

                    const labelTex = createLabelTexture(idCounter);

                    const centerPhi = phiStart + phiLen/2; 
                    const centerTheta = thetaStart + thetaLen/2;
                    const x = -SPHERE_RADIUS * Math.sin(centerTheta) * Math.cos(centerPhi);
                    const y = SPHERE_RADIUS * Math.cos(centerTheta);
                    const z = SPHERE_RADIUS * Math.sin(centerTheta) * Math.sin(centerPhi);
                    const centerPos = new THREE.Vector3(x,y,z);

                    const material = new THREE.ShaderMaterial({
                        vertexShader: nodeVertexShader,
                        fragmentShader: nodeFragmentShader,
                        uniforms: {
                            uColor: { value: NEON_RED },
                            uOpacity: { value: isContent ? 0.9 : 0.3 },
                            uHover: { value: 0 },
                            uLabel: { value: labelTex }
                        },
                        side: THREE.DoubleSide, 
                        transparent: true, 
                        depthWrite: false, 
                        blending: THREE.AdditiveBlending
                    });

                    const mesh = new THREE.Mesh(geo, material);
                    mesh.position.set(0,0,0);
                    mesh.rotation.set(0,0,0);
                    
                    mesh.userData = { 
                        id: idCounter, 
                        row: r,
                        col: c,
                        isContent: isContent,
                        centerPos: centerPos
                    };

                    sphereGroup.add(mesh); 
                    meshes[r][c] = mesh;
                    meshFlatList.push(mesh);
                    idCounter++;
                }
            }

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('click', onClick, false);
            window.addEventListener('wheel', onWheel, { passive: false });
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd, { passive: false });
            
            animate();
        }

        function registerInteraction() {
            state.lastInteractionTime = Date.now();
        }

        let waveTime = 0;
        function drawWaveform() {
            const w = waveCanvas.width = window.innerWidth;
            const h = waveCanvas.height = 150;
            
            waveCtx.clearRect(0,0,w,h);
            waveCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            waveCtx.lineWidth = 1;
            waveTime += 0.02; 
            
            const ampBase = 20; 

            for(let l = 0; l < 2; l++) {
                waveCtx.beginPath();
                waveCtx.strokeStyle = `rgba(255, 255, 255, ${0.1 + (l*0.1)})`; 
                for(let x = 0; x < w; x+=5) {
                    const n1 = Math.sin(x * 0.005 + waveTime + (l*10)) * ampBase;
                    const n2 = Math.cos(x * 0.01 - waveTime) * (ampBase * 0.5);
                    const y = (h/2) + n1 + n2;
                    if(x===0) waveCtx.moveTo(x,y);
                    else waveCtx.lineTo(x,y);
                }
                waveCtx.stroke();
            }
        }

        function onWheel(e) {
            e.preventDefault();
            registerInteraction();
            state.cameraZ += e.deltaY * 0.05;
            state.cameraZ = Math.max(20, Math.min(150, state.cameraZ));
            camera.position.z = state.cameraZ;
            const zoomPct = Math.round((REFERENCE_ZOOM_Z / state.cameraZ) * 100);
            uiZoom.innerText = zoomPct;
        }

        function onTouchStart(e) { 
            registerInteraction();
            if (e.touches.length === 1) { 
                state.isDragging = true; 
                state.lastTouchX = e.touches[0].clientX; 
                state.lastTouchY = e.touches[0].clientY; 
                state.velocityLon = 0;
                state.velocityLat = 0;
            } else if (e.touches.length === 2) {
                state.isDragging = false; 
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                state.pinchStartDist = dist;
                state.pinchStartZ = state.cameraZ;
            }
        }
        
        function onTouchMove(e) { 
            registerInteraction();
            if (e.touches.length === 1 && state.isDragging) { 
                const x = e.touches[0].clientX; 
                const y = e.touches[0].clientY; 
                const deltaX = x - state.lastTouchX;
                const deltaY = y - state.lastTouchY;
                state.rotLon -= deltaX * 0.2; 
                state.rotLat += deltaY * 0.2; 
                state.velocityLon = -deltaX * 0.1;
                state.velocityLat = deltaY * 0.1;
                state.lastTouchX = x; 
                state.lastTouchY = y; 
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const scale = state.pinchStartDist / dist;
                state.cameraZ = Math.max(20, Math.min(150, state.pinchStartZ * scale));
                camera.position.z = state.cameraZ;
                const zoomPct = Math.round((REFERENCE_ZOOM_Z / state.cameraZ) * 100);
                uiZoom.innerText = zoomPct;
            }
        }
        
        function onTouchEnd(e) { state.isDragging = false; registerInteraction(); }
        
        function onMouseDown(e) { 
            registerInteraction();
            state.isDragging = true; 
            state.lastTouchX = e.clientX; 
            state.lastTouchY = e.clientY; 
            state.velocityLon = 0;
            state.velocityLat = 0;
        }
        
        function onMouseMove(e) { 
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; 
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; 
            if(state.isDragging) { 
                registerInteraction();
                const deltaX = e.clientX - state.lastTouchX;
                const deltaY = e.clientY - state.lastTouchY;
                state.rotLon -= deltaX * 0.2; 
                state.rotLat += deltaY * 0.2; 
                state.velocityLon = -deltaX * 0.1;
                state.velocityLat = deltaY * 0.1;
                state.lastTouchX = e.clientX; 
                state.lastTouchY = e.clientY; 
            } 
        }
        
        function onMouseUp() { state.isDragging = false; }
        function onClick() { }
        
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate);
            drawWaveform();
            
            const now = Date.now();
            const time = (now - state.startTime) * 0.001;

            const timeSinceInteract = now - state.lastInteractionTime;
            const isIdle = timeSinceInteract > IDLE_TIMEOUT;

            if (!state.isDragging) {
                state.rotLon += state.velocityLon;
                state.rotLat += state.velocityLat;
                state.velocityLon *= 0.95;
                state.velocityLat *= 0.95;
                
                if (isIdle) {
                    state.cameraZ += (DEFAULT_ZOOM_Z - state.cameraZ) * 0.01;
                    camera.position.z = state.cameraZ;
                    const zoomPct = Math.round((REFERENCE_ZOOM_Z / state.cameraZ) * 100);
                    uiZoom.innerText = zoomPct;
                    state.rotLat += (0 - state.rotLat) * 0.02;
                    if (Math.abs(state.velocityLon) < 0.05) state.velocityLon = 0.05;
                } else {
                    if(Math.abs(state.velocityLon) < 0.05) state.velocityLon += 0.002; 
                }
            }
            
            const targetRotY = THREE.MathUtils.degToRad(state.rotLon);
            const targetRotX = THREE.MathUtils.degToRad(state.rotLat);

            sphereGroup.rotation.y += (targetRotY - sphereGroup.rotation.y) * 0.1;
            sphereGroup.rotation.x += (targetRotX - sphereGroup.rotation.x) * 0.1;
            
            if(coinGroup) {
                coinGroup.rotation.y = -sphereGroup.rotation.y;
                coinLayers.forEach(layer => {
                    layer.material.uniforms.uTime.value = time;
                });
            }

            if(debugMom) debugMom.innerText = state.velocityLon.toFixed(2);

            let hoveredObject = null; 
            if (!state.isDragging) {
                if (mouse.x > -1 && mouse.x < 1 && mouse.y > -1 && mouse.y < 1) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(meshFlatList);
                    if (intersects.length > 0) {
                        hoveredObject = intersects[0].object;
                    }
                }
            }

            meshFlatList.forEach((mesh) => {
                const mat = mesh.material;
                let isHovered = (mesh === hoveredObject);
                mat.uniforms.uHover.value += ((isHovered ? 1.0 : 0.0) - mat.uniforms.uHover.value) * 0.1;
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


